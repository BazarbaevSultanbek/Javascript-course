
// "use strict"

// export let messages = [
//   {text: "Hello", from: "John"},
//   {text: "How goes?", from: "John"},
//   {text: "See you soon", from: "Alice"}
// ]


// У вас есть к ним доступ, но управление этим массивом происходит где-то ещё. Добавляются новые сообщения и удаляются старые, и вы не знаете в какой момент это может произойти.

// Имея такую вводную информацию, решите, какуюa структуру данных вы могли бы использовать для ответа на вопрос «было ли сообщение прочитано?». 
// Структура должна быть подходящей, чтобы можно было однозначно сказать, было ли прочитано это сообщение для каждого объекта сообщения.

// P.S. Когда сообщение удаляется из массива messages, оно должно также исчезать из структуры данных.

// P.P.S. Нам не следует модифицировать сами объекты сообщений, добавлять туда свойства. Если сообщения принадлежат какому-то другому коду, то это может привести к плохим последствиям.




// 2) let messages = [
//   { text: "Hello", from: "John" },
//   { text: "How goes?", from: "John" },
//   { text: "See you soon", from: "Alice" }
// ];

// Теперь вопрос стоит так: какую структуру данных вы бы предложили использовать для хранения информации о том, когда сообщение было прочитано?

// В предыдущем задании нам нужно было сохранить только факт прочтения «да или нет». Теперь же нам нужно сохранить дату, и она должна исчезнуть из памяти при удалении «сборщиком мусора» сообщения.


// 3) Допустим, у нас есть массив arr.

// Создайте функцию unique(arr), которая вернёт массив уникальных, не повторяющихся значений массива arr.

// function unique(arr) {
//   /* ваш код */
// }


// alert( unique(values) ); // Hare,Krishna,:-O

// let values = ["Hare", "Krishna", "Hare", "Krishna",
//   "Krishna", "Krishna", "Hare", "Hare", ":-O"
// ];
// function unique(arr) {
//   let set = new Set(arr)
//   console.log(set);
// } unique(values)

// P.S. Здесь мы используем строки, но значения могут быть любого типа.

// 4) Анаграммы – это слова, у которых те же буквы в том же количестве, но они располагаются в другом порядке.
// Например
// nap - pan
// ear - are - era
// cheaters - hectares - teachers

// Напишите функцию aclean(arr), которая возвращает массив слов, очищенный от анаграмм.


// let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

// let arr2 = arr.map((item)=>item.toLocaleLowerCase().split("").sort().join(""))

// let set = new Set()

// arr2.forEach((item)=>set.add(item))


// console.log(set);


// alert( aclean(arr) ); // "nap,teachers,ear" or "PAN,cheaters,era"
// Из каждой группы анаграмм должно остаться только одно слово, не важно какое.


// 5) Мы хотели бы получить массив ключей map.keys() в переменную и далее работать с ними, например, применить метод .push.

// Но это не выходит:

// let map = new Map();

// map.set("name", "John");


// let keys = []
// keys.push(...map)
// keys.push('more')
// console.log(keys);

// let keys = map.keys();
// // Error: keys.push is not a function
// // Ошибка: keys.push -- это не функция
// keys.push("more");
// Почему? Что нужно поправить в коде, чтобы вызов keys.push сработал?r")
// set.add("era")
// set.add("hectares")

// for (let user of set) {
//     console.log(user.value);
//   }
// // }aclean()

